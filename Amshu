DIFFIE HELMAN
def prime_checker(p):
	if p < 1:
		return -1
	elif p > 1:
		if p == 2:
			return 1
		for i in range(2, p):
			if p % i == 0:
				return -1
			return 1


def primitive_check(g, p, L):
	# Checks If The Entered Number Is A Primitive Root Or Not
	for i in range(1, p):
		L.append(pow(g, i) % p)
	for i in range(1, p):
		if L.count(i) > 1:
			L.clear()
			return -1
		return 1


l = []
while 1:
	P = int(input("Enter P : "))
	if prime_checker(P) == -1:
		print("Number Is Not Prime, Please Enter Again!")
		continue
	break

while 1:
	G = int(input(f"Enter The Primitive Root Of {P} : "))
	if primitive_check(G, P, l) == -1:
		print(f"Number Is Not A Primitive Root Of {P}, Please Try Again!")
		continue
	break

# Private Keys
x1, x2 = int(input("Enter The Private Key Of User 1 : ")), int(
	input("Enter The Private Key Of User 2 : "))
while 1:
	if x1 >= P or x2 >= P:
		print(f"Private Key Of Both The Users Should Be Less Than {P}!")
		continue
	break

# Calculate Public Keys
y1, y2 = pow(G, x1) % P, pow(G, x2) % P

# Generate Secret Keys
k1, k2 = pow(y2, x1) % P, pow(y1, x2) % P

print(f"\nSecret Key For User 1 Is {k1}\nSecret Key For User 2 Is {k2}\n")

if k1 == k2:
	print("Keys Have Been Exchanged Successfully")
else:
	print("Keys Have Not Been Exchanged Successfully")


************************************************************************************************


EUCLID
def gcd(a, b):
    if a == 0:
        return b
    return gcd(b % a, a)

def gcdExtended(a, b):

    if a == 0:
        return b, 0, 1
    gcd, x1, y1 = gcdExtended(b % a, a)
    x = y1 - (b//a) * x1
    y = x1
    return gcd, x, y
    
a = int(input())
b = int(input())
print("gcd(", a, ",", b, ") = ", gcd(a, b), gcdExtended(a,b))

**************************************************************************************
RSA
import math
def gcd(a, h):
	temp = 0
	while(1):
		temp = a % h
		if (temp == 0):
			return h
		a = h
		h = temp
p = 3
q = 7
n = p*q
e = 2
phi = (p-1)*(q-1)

while (e < phi):
	if(gcd(e, phi) == 1):
		break
	else:
		e = e+1
k = 2
d = (1 + (k*phi))/e
msg = 12.0

print("Message data = ", msg)
c = pow(msg, e)
c = math.fmod(c, n)
print("Encrypted data = ", c)
m = pow(c, d)
m = math.fmod(m, n)
print("Original Message Sent = ", m)

**********************************************************************************
SHA 1
def sha1(data):
    bytes = ""

    h0 = 0x67452301
    h1 = 0xEFCDAB89
    h2 = 0x98BADCFE
    h3 = 0x10325476
    h4 = 0xC3D2E1F0

    for n in range(len(data)):
        bytes+='{0:08b}'.format(ord(data[n]))
    bits = bytes+"1"
    pBits = bits
    #pad until length equals 448 mod 512
    while len(pBits)%512 != 448:
        pBits+="0"
    #append the original length
    pBits+='{0:064b}'.format(len(bits)-1)

    def chunks(l, n):
        return [l[i:i+n] for i in range(0, len(l), n)]

    def rol(n, b):
        return ((n << b) | (n >> (32 - b))) & 0xffffffff

    for c in chunks(pBits, 512): 
        words = chunks(c, 32)
        w = [0]*80
        for n in range(0, 16):
            w[n] = int(words[n], 2)
        for i in range(16, 80):
            w[i] = rol((w[i-3] ^ w[i-8] ^ w[i-14] ^ w[i-16]), 1)  

        a = h0
        b = h1
        c = h2
        d = h3
        e = h4

        #Main loop
        for i in range(0, 80):
            if 0 <= i <= 19:
                f = (b & c) | ((~b) & d)
                k = 0x5A827999
            elif 20 <= i <= 39:
                f = b ^ c ^ d
                k = 0x6ED9EBA1
            elif 40 <= i <= 59:
                f = (b & c) | (b & d) | (c & d) 
                k = 0x8F1BBCDC
            elif 60 <= i <= 79:
                f = b ^ c ^ d
                k = 0xCA62C1D6

            temp = rol(a, 5) + f + e + k + w[i] & 0xffffffff
            e = d
            d = c
            c = rol(b, 30)
            b = a
            a = temp

        h0 = h0 + a & 0xffffffff
        h1 = h1 + b & 0xffffffff
        h2 = h2 + c & 0xffffffff
        h3 = h3 + d & 0xffffffff
        h4 = h4 + e & 0xffffffff

    return '%08x%08x%08x%08x%08x' % (h0, h1, h2, h3, h4)

print sha1("hello world")
***********************************************************************************

RC4
def rc4_init(key):
    """Initialize the RC4 state with the given key."""
    s = list(range(256))
    j = 0

    for i in range(256):
        j = (j + s[i] + key[i % len(key)]) % 256
        s[i], s[j] = s[j], s[i]

    return s


def rc4_generate_keystream(s):
    """Generate a keystream byte from the RC4 state."""
    i = j = 0
    i = (i + 1) % 256
    j = (j + s[i]) % 256
    s[i], s[j] = s[j], s[i]
    return s[(s[i] + s[j]) % 256]


def rc4_encrypt(key, plaintext):
    """Encrypt plaintext using RC4 with the given key."""
    s = rc4_init(key)
    ciphertext = bytearray()

    for byte in plaintext:
        keystream_byte = rc4_generate_keystream(s)
        ciphertext.append(byte ^ keystream_byte)

    return ciphertext

def rc4_decrypt(key, ciphertext):
    """Decrypt ciphertext using RC4 with the given key."""
    return rc4_encrypt(key, ciphertext)


if _name_ == "_main_":
    # Custom key
    key = b"my_secret_key"

    # Plaintext to encrypt
    plaintext = b"hello world"

    # Encrypt the plaintext
    ciphertext = rc4_encrypt(key, plaintext)

    print("Ciphertext:", ciphertext)

    # Decrypt the ciphertext
    decrypted_text = rc4_decrypt(key, ciphertext)
    print("Decrypted text:", decrypted_text)

***************************************************************************

MD5
def md5(message):
    # Initialize the hash value
    h0 = 0x01234567
    h1 = 0x89abcdef
    h2 = 0xfedcba98
    h3 = 0x76543210

    # Pre-processing
    message = message.encode('utf-8')  # Encode the string to bytes
    message_length = len(message)

    # Calculate the length of the original message in bits
    message_length_bits = message_length * 8

    # Calculate the number of bytes needed to pad the message
    padding_length = (64 - (message_length_bits + 8) % 64) % 64

    # Create the padded_message by concatenating the components
    padded_message = message + b'\x80' + b'\x00' * padding_length + message_length_bits.to_bytes(8, byteorder='little')

    # Process the message in 512-bit chunks
    for chunk in [padded_message[i:i+64] for i in range(0, len(padded_message), 64)]:
        a = h0
        b = h1
        c = h2
        d = h3

        # Perform the four rounds of MD5
        for i in range(0, 64):
            if 0 <= i <= 15:
                f = (b & c) ^ (~b & d)
                g = 0
                k = 0x0000000F + i
            elif 16 <= i <= 31:
                f = (d & b) ^ (~d & c)
                g = 1
                k = 0x10000005 + i
            elif 32 <= i <= 47:
                f = (a & b) ^ (~a & c)
                g = 2
                k = 0x20000000 + i
            elif 48 <= i <= 63:
                f = (a & d) ^ (~a & b)
                g = 3
                k = 0x30000000 + i

            h0 = (h0 + f + g + k + int.from_bytes(chunk[i:i+4], byteorder='little')) & 0xFFFFFFFF
            h1 = (h1 + h0) & 0xFFFFFFFF
            h2 = (h2 + h1) & 0xFFFFFFFF
            h3 = (h3 + h2) & 0xFFFFFFFF
            temp = h0
            h0 = h3
            h3 = h2
            h2 = h1
            h1 = temp

    # Combine the hash values into a 128-bit hash
    hash_value = h0 << 112 | h1 << 88 | h2 << 64 | h3 << 32
    return hex(hash_value)

# Get input from the user
message = input("Enter a message to hash: ")

# Hash the message and print the result
md5_hash = md5(message)
print("MD5 hash:", md5_hash)


***********************************************************************************************************
SHA
import hashlib
str = "GeeksforGeeks"
result = hashlib.sha1(str.encode()) 
print("The hexadecimal equivalent of SHA1 is : ") 
print(result.hexdigest())
